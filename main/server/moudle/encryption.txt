我设计的加密算法：
1.加密过程：
   1）读取文件大小，将大小保存为变量：size
   2）读取第1，2，size-1，size字节的数据，这组数据在下面简称为[FE 21]，组合成一个4字节的加密码，保存为变量：encryption-key
   3）读取文件所有字节，将文件除第1，2，size-1，size字节的所有字节分割为16字节的加密区，多余的不作处理。
   4）在文件每个加密区的第F，E，2，1位后分别加入1，2，E，F，得到一个1.25倍大小的新加密区。
   5）组合所有加密区的字节，得到一个新文件，导出另存为加密文件即可。
2.解密过程：
   1）读取文件大小，将大小保存为变量：size
   2）读取第1，2，size-1，size字节的数据，并将数据按从小到大的顺序排列得到新数据：解密码(这组数据在下面简称为[12 EF])保存为变量：decrypt-key
   3）将文件除第1，2，size-1，size字节的所有字节分割为20字节的解密区，多余的不作处理。
   4）检查每个解密区的第1+1，2+2，E+3，F+4位是否与对应的解密码相同。（如果不同则报错：ERROR108：bytes not currect.）
   5）把每个解密区的第1+1，2+2，E+3，F+4位删去，并计算HASH值，与服务器端发送的原文件HASH值比较，如果相同，导出为文件，如果不同，报错：ERROR107:HASH not currect.
   6）把解密完的解密区字节组合为文件，导出即可。
3.加密示例：
   1）原文件：EA 57 EF F7 7B AF 5E D7 CC 13 52 27 47 56 06 BD 5E 98
   2）读取大小：[size] = 36
   3）读取第1，2，size-1，size字节的数据，组合为加密码：encryption-key=[EA 98]
   4）计算原文件HASH：b0cb89ecca3580e5e74bb66545bdfacc9b57ab73b6f6488c1bd5dae2f7858e8698187b17d550cf4003edcea76bc98e1514669814ba0db8a6b04c6bcf0e13a37f
   5）分割加密区：[57 EF F7 7B AF 5E D7 CC]，[13 52 27 47 56 06 BD 5E]
   6）加密加密区：[57 EF F7 7B EA AF 59 ED 7C 8C]，[13 52 27 47 E5 A6 09 6B D5 8E]
   7）组合文件：EA 57 EF F7 7B EA AF 59 ED 7C 8C 13 52 27 47 E5 A6 09 6B D5 8E 98
   8）输出为加密文件：file.block
4.解密示例：
   1）加密文件：EA 57 EF F7 7B EA AF 59 ED 7C 8C 13 52 27 47 E5 A6 09 6B D5 8E 98
   2）读取大小：[size] = 44
   3）读取第1，2，size-1，size字节的数据，组合为加密码：encryption-key=[EA 98]
   4）把加密码按从小到大排列得到解密码：decrypt-key=[89 AE]
   5）分割解密区：[57 EF F7 7B EA AF 59 ED 7C 8C]，[13 52 27 47 E5 A6 09 6B D5 8E]
   6）检查解密区：[57 EF F7 7B =A =F 5= ED 7C =C]，[13 52 27 47 =5 =6 0= 6B D5 =E](解密检查：通过)
   6）解密解密区：[57 EF F7 7B AF 5E D7 CC]，[13 52 27 47 56 06 BD 5E]
   7）组合源文件：EA 57 EF F7 7B AF 5E D7 CC 13 52 27 47 56 06 BD 5E 98
   8）计算文件HASH：b0cb89ecca3580e5e74bb66545bdfacc9b57ab73b6f6488c1bd5dae2f7858e8698187b17d550cf4003edcea76bc98e1514669814ba0db8a6b04c6bcf0e13a37f
   9）比较HASH：相同，通过。
   10）输出为最终文件：file.zip